from __future__ import annotations

from typing import Dict, List, Optional

from pydantic import BaseModel, Field, model_validator


class QueryPlanStep(BaseModel):
    step_id: int = Field(..., ge=1, description="Sequential identifier of the sub-question.")
    question: str = Field(..., min_length=3, description="Sub-question text generated by the planner.")
    rationale: str = Field(
        default="",
        description="Short explanation why this sub-question is needed or what aspect it covers.",
    )


class QueryDecompositionPlan(BaseModel):
    original_query: str = Field(..., description="Original complex query issued by the user.")
    steps: List[QueryPlanStep] = Field(..., min_length=2, description="Ordered sub-questions to execute.")

    @model_validator(mode="after")
    def _validate_order(self) -> "QueryDecompositionPlan":
        ids = [step.step_id for step in self.steps]
        if sorted(ids) != list(range(1, len(self.steps) + 1)):
            raise ValueError("step_id values must be consecutive starting from 1.")
        return self


class SubQueryAnswer(BaseModel):
    step_id: int
    sub_query: str
    answer: str = ""
    retrieved_chunks: List[Dict[str, object]] = Field(default_factory=list)
    metadata: Dict[str, object] = Field(default_factory=dict)


class QueryDecompositionOutput(BaseModel):
    original_query: str
    plan: QueryDecompositionPlan
    sub_answers: List[SubQueryAnswer]
    final_answer: str
    aggregator_notes: Optional[str] = None
    timings: Dict[str, float] = Field(default_factory=dict)
